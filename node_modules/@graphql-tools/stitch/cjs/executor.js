"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStitchingExecutor = void 0;
const utils_1 = require("@graphql-tools/utils");
// eslint-disable-next-line import/no-extraneous-dependencies
const executor_1 = require("@graphql-tools/executor");
const delegate_1 = require("@graphql-tools/delegate");
/**
 * Creates an executor that uses the schema created by stitching together multiple subschemas.
 * Not ready for production
 * Breaking changes can be introduced in the meanwhile
 *
 * @experimental
 *
 */
function createStitchingExecutor(stitchedSchema) {
    var _a;
    const subschemas = [...((_a = stitchedSchema.extensions) === null || _a === void 0 ? void 0 : _a['stitchingInfo']).subschemaMap.values()];
    return async function stitchingExecutor(executorRequest) {
        var _a, _b;
        const fragments = (0, executor_1.getFragmentsFromDocument)(executorRequest.document);
        const operation = (0, utils_1.getOperationASTFromRequest)(executorRequest);
        const rootType = (0, utils_1.getDefinedRootType)(stitchedSchema, operation.operation);
        const { fields } = (0, utils_1.collectFields)(stitchedSchema, fragments, executorRequest.variables, rootType, operation.selectionSet);
        const data = {};
        for (const [fieldName, fieldNodes] of fields) {
            const responseKey = (_b = (_a = fieldNodes[0].alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : fieldName;
            const subschemaForField = subschemas.find(subschema => {
                const subschemaSchema = (0, delegate_1.isSubschemaConfig)(subschema) ? subschema.schema : subschema;
                const rootType = (0, utils_1.getDefinedRootType)(subschemaSchema, operation.operation);
                return rootType.getFields()[fieldName] != null;
            });
            let result = await (0, delegate_1.delegateToSchema)({
                schema: subschemaForField || stitchedSchema,
                rootValue: executorRequest.rootValue,
                context: executorRequest.context,
                info: {
                    schema: stitchedSchema,
                    fieldName,
                    fieldNodes,
                    operation,
                    fragments,
                    parentType: rootType,
                    returnType: rootType.getFields()[fieldName].type,
                    variableValues: executorRequest.variables,
                },
            });
            if (Array.isArray(result)) {
                result = await Promise.all(result);
            }
            data[responseKey] = result;
        }
        return { data };
    };
}
exports.createStitchingExecutor = createStitchingExecutor;
