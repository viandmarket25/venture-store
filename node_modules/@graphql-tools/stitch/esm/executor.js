import { collectFields, getDefinedRootType, getOperationASTFromRequest } from '@graphql-tools/utils';
// eslint-disable-next-line import/no-extraneous-dependencies
import { getFragmentsFromDocument } from '@graphql-tools/executor';
import { delegateToSchema, isSubschemaConfig } from '@graphql-tools/delegate';
/**
 * Creates an executor that uses the schema created by stitching together multiple subschemas.
 * Not ready for production
 * Breaking changes can be introduced in the meanwhile
 *
 * @experimental
 *
 */
export function createStitchingExecutor(stitchedSchema) {
    var _a;
    const subschemas = [...((_a = stitchedSchema.extensions) === null || _a === void 0 ? void 0 : _a['stitchingInfo']).subschemaMap.values()];
    return async function stitchingExecutor(executorRequest) {
        var _a, _b;
        const fragments = getFragmentsFromDocument(executorRequest.document);
        const operation = getOperationASTFromRequest(executorRequest);
        const rootType = getDefinedRootType(stitchedSchema, operation.operation);
        const { fields } = collectFields(stitchedSchema, fragments, executorRequest.variables, rootType, operation.selectionSet);
        const data = {};
        for (const [fieldName, fieldNodes] of fields) {
            const responseKey = (_b = (_a = fieldNodes[0].alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : fieldName;
            const subschemaForField = subschemas.find(subschema => {
                const subschemaSchema = isSubschemaConfig(subschema) ? subschema.schema : subschema;
                const rootType = getDefinedRootType(subschemaSchema, operation.operation);
                return rootType.getFields()[fieldName] != null;
            });
            let result = await delegateToSchema({
                schema: subschemaForField || stitchedSchema,
                rootValue: executorRequest.rootValue,
                context: executorRequest.context,
                info: {
                    schema: stitchedSchema,
                    fieldName,
                    fieldNodes,
                    operation,
                    fragments,
                    parentType: rootType,
                    returnType: rootType.getFields()[fieldName].type,
                    variableValues: executorRequest.variables,
                },
            });
            if (Array.isArray(result)) {
                result = await Promise.all(result);
            }
            data[responseKey] = result;
        }
        return { data };
    };
}
